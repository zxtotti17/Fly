{"pages":[{"title":"About-me","text":"一句话 Just do it ! (翻译：我只是个搞 IT的！哭笑脸) 关于我 一个莫名其妙的，喜欢敲代码，喜欢研究技术的，表面上高冷、不苟言笑的， 偶尔又嬉皮笑脸，偶尔又特立独行的，双重性格的技术爱好者！ 兴趣方向 游戏。 联系我 Email: 574215066@qq.com","path":"about-me/index.html"},{"title":"Archives","text":"","path":"archives/index.html"},{"title":"Categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"Erlang OTP学习","text":"1.-behaviour(gen_server)它表示让编译器检查，当前module是否实现了gen_server指定的所有回调接口 2.gen_server:start_link(ServerName, Module, Args, Options) -&gt; Result这个方法用来启动一个server，其中：参数ServerName指定了服务名参数Module指定了该server的callback模块参数Args将作为服务初始化的启动参数（服务初始化时会调用：Module:init([Args])）参数Options指定了一些特性参数，通常可以直接使用[] 如果服务启动成功，返回{ok, Pid} 3.Module:init([Args])这个方法会在服务初始化时被回调，参数Args就是gen_server:start_link中倒数第二个参数，若初始化成功，该方法放回{ok, State},其中State将作为启动服务的State 4.gen_server:call(ServerRef, Request)这个方法供callback模块向ServerRef代表的服务发送Request请求（callback模块通常会在之上再封装一层接口供客户端调用，譬如这里的add，find方法），注意该方法是一个同步调用，它会一直等待服务器返回一个响应消息（除非等待超时，默认5s） 5.Module:handle_call(Request, From, State) -&gt; Result这是一个回调方法，用来处理gen_server:call(ServerRef, Request)发出的请求，其中：Request，表示客户端请求From，表示请求来自哪个客户端State，表示当前服务器状态 Result为handle_call 请求处理结果，它有以下几种类型{reply,Reply,NewState}{reply,Reply,NewState,Timeout}{reply,Reply,NewState,hibernate}{noreply,NewState}{noreply,NewState,Timeout}{noreply,NewState,hibernate}{stop,Reason,Reply,NewState} | {stop,Reason,NewState} 这几种返回值有什么区别呢？如果返回的是以reply开头，那么Reply将会作为响应返回给客户端如果返回的是以noreply开头，那么服务器将不会返回任何消息给客户端（这会导致客户端阻塞，因为客户端调用的gen_server:call方法是一个同步调用，当它发出请求后，会一直等待服务器发送响应消息，除非等待超时） 6.gen_server:cast(ServerRef, Request)这个方法同gen_server:call(ServerRef, Request)，但它最大的区别就是该调用是异步的，它不需要等待服务器返回任何处理结果 7.Module:handle_cast(Request, State) -&gt; Result这个方法用来处理gen_server:cast(ServerRef, Request)发出的请求，由于不会返回结果给客户端，所以参数列表中也没有From","path":"2019/04/09/Erlang-OTP学习/"},{"title":"Erlang语言学习","text":"Erlang特点","path":"2019/03/07/Erlang语言学习/"},{"title":"充值流程","text":"接触到的充值流程是这样的客户端发起请求-&gt;lcm后台，lcm后台确认充值成功，会将充值的金额变成平台货币保存在平台端，并通知到客户端充值成功，收到充值成功的客户端对游戏服务端发起请求，游戏服务端收到请求后，请求lcm平台调用spend方法，平台确认信息相符就扣币并告诉游戏服务端消费成功，游戏服务端在将平台货币转换为对应的游戏币，同时告诉客户端充值成功 2.平台充值成功可能会产生回调直接通知游戏服务端，服务端接收请求，后请求平台spend，成功后发币记录，客户端请求服务端查到有记录就告知客户端成功不做spend 掉单：如果掉单1.平台回调请求会保证执行spend方法，达到补单的效果2.客户端能读到平台币，直接通过平台剩余币与游戏服务端直接交易 注意：任何时间判断以天为单位要特别小心，如果出现两版批次连续很容易出问题","path":"2019/03/06/充值流程/"},{"title":"c++设计模式","text":"c++设计模式： 简单工厂模式 工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。 使用情景： 在不确定会有多少个处理操作时应该考虑使用简单工厂模式，如针对同样的接收到的数据，处理的逻辑可能会不同，可能以后还会增加新的操作。案例：如果实现计算器的功能时，对于同样的输入数据，可能执行加、减、乘、除，甚至其他的功能。因此可以抽象出一个操作的抽象类或是接口，提供一个统一的处理方法(此处为process)，然后每种操作创建出一个子类出来。而判断具体使用哪个具体的实现类是在工厂类中进行判断的(将存放操作的变量传递给工厂的生产方法)。工厂类始终返回的是这个抽象类，这样如果对原有功能进行更改或是新添加新的功能，也不会对原来的其他类做修改，只编译修改的那个类或是新的类就可以了。这样就做到了把耦合降到最低，同时也便于维护。 简单工厂：针对同样的数据，不同的操作用同一个接口 工厂方法：针对同样的数据，不同的操作用不同的接口 抽象工厂：针对不同的数据，不同的操作用不同的接口 策略模式：依赖c++的多态，抽象类的指针可以访问所有子类对象，（纯虚函数），可以用一个指针访问所有策略的实现类 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式(不能让一个程序打开两次 如：不能同时打开2个迅雷 迅雷用的单例模式) 访问者模式:适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中(做任何更改不需要修改基类，不依赖虚函数) 观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。(QT的信号机制，Windows的消息机制都应用了观察者模式，还有订阅邮件，邮件到了就会给你发邮件) 建造者模式：使得产品内部表象可以独立地变化，客户不必知道产品内部组成的细节。可以强制实行一种分步骤进行的建造过程。用一个接口完成不同的操作，需要对客户的需求进行把握。(如：登陆QQ，自动选择所在地的服务器) 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。(如：360读取lua脚本，这个细节的实现就是解释器模式) 命令模式：把发出命令的责任和执行命令的责任分割开，委派给不同的对象允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。(命令模式在客户端与服务器之间用的最多 (C/S架构)) 模板模式：不同的子类可以以不同的方式实现这些抽象方法， 从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架， 而将逻辑的细节留给具体的子类去实现。(适用于本地化，做一个软件，在日本是日文，美国是英语…) 桥接模式：将抽象化与实现化脱离，使得二者可以独立的变化， 也就是指在一个软件系统的抽象化和实现化之间使用组合聚合关系而不是继承关系，从而使两者可以独立的变化。(相当于配电脑去装机，把各个模块组合到一起) 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。 外观模式：外部与一个子系统的通信必须通过一个统一的外观对象进行。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个外观类。(多个子系统方法都需要一个外观类统一管理，用统一的接口方便消费者使用) 享元模式：享元模式大幅度的降低内存中对象的数量，使用享元模式主要是为了优化内存，相同功能可以并行使用。 原型模式：允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。(例如：晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了) 中介者模式：中介者模式包装了一系列对象相互作用的方式， 使得这些对象不必相互明显作用。从而使他们可以松散偶合。 当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。（如：TCP/IP打洞技术） 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 状态模式：意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。(如：到了晚上12点要睡觉，到了早上8点要起床…这就是状态) 合成模式：将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。(用于树状结构)","path":"2018/12/25/c-设计模式/"},{"title":"Mysql笔记","text":"第1章 SQL基础1.数据分为DDL(数据定义语言)，DML(数据操纵语言)，DCL(数据控制语言) 1.1 DDL语句 123456789101112131415mysql -uroot -pcreate database test1;use test1;show tables; #查看所有表drop database test1;create table emp(ename varchar(10),hiredate date,sal decimal(2,10),deptno int(2));desc emp; #查看表信息show create table emp \\G; #\\G使得记录能够按照字段竖向排列 以便显示更长内容drop table emp;alter table emp modify ename varchar(20); #修改表字段alter table emp add column age int(3); #添加字段alter table emp drop colum age #删除字段alter table emp change age age123 int(4); #字段改名同时修改类型alter table emp add birth date after ename; #修改字段排列顺序alter table emp rename emp1; 1.2 DML语句 增删改查 12345678910insert into emp (ename,sal) values('dony',1000);delete from emp where ename = 'xxx';select distinct age from emp1; #查询的内容去重select * from emp order by age,deptno desc; #根据某个字段排序 select age,count(1) from emp group by age with rollup; #分类统计计数及总数 select age,count(1) from emp group by age having count(1)&gt;1; select ename,deptname from emp,dept where emp.age = dept.age; #联查,内链接 select ename,deptname from emp left jion dept on emp.deptno = dept.deptno; #表链接很多情况下优于子查询 select * from dept union all select * from emp; #集合显示不去重 select * from dept union select * from emp; #集合显示去重 You can&apos;t specify target table &apos; for update in FROM clause Mysql不让对查询到的目标语句进行更新 1DELETE FROM playeritems WHERE id IN(SELECT mid FROM (SELECT min(id) as mid FROM playeritems WHERE uid = '1300200112870961' GROUP BY iname HAVING count(iname) &gt; 1 )as tmp); 1.3 DCL语句 12grant select,insert on sakila.* to 'z1@localhost' identified by '123'; #赋予用户权限revoke insert on sakila.* from 'z1@localhost'; #回收权限 2.常用函数 1234567891011select NOW(); #xxxx-xx-xx xx:xx:xxselect UNIX_TIMESTAMP(now()); #时间戳select FROM_UNIXTIME(时间戳); #xxxx-xx-xx xx:xx:xxIF(value,t,f) #如果value为真，返回t,否则返回fselect if(a &gt; 2000, 'high','low') from BIFNULL(value1,value2) #如果value1不为空，返回value1,否则返回value2select ifnull(a , 0) from BCASE WHEN value THEN res1 ... ELSE def END #如果value1真，返回res1,否则返回defselect case when a&lt;2000 then 'low' else 'high' end from BCASE exp WHEN value THEN res1 ... ELSE def END #如果exp = value1真，返回res1,否则返回defselect case a when 1000 then 'low' when 2000 then 'mid' else 'high' end from B 第2章 存储引擎1.mysql的存储引擎有好多种，这边记录2种 1.1 MyISAM 不支持事务、不支持外键、速度快、表锁 1.2 InnoDB 支持提交、回滚、奔溃恢复能力的事务安全，行锁 2.myssql事务123start transaction;sql 操作commit and chain; 3.防止sql注入123456$re = \"/(|\\'|(\\%27)|\\;|(\\%3b)|\\=|(\\%3d)|\\(|(\\%28)|\\)|(\\%29)|(\\/*) |(\\%2f%2a)|(\\ */)|(\\%2a%2f)|\\+|(\\%2b)|\\&lt;|(\\%3c)|\\&gt;|(\\%3e)|\\(--))|\\[|\\%5b|\\]|\\%5d)/\";if(preg_match($re, $aa) &gt;0)&#123; echo(\"参数不对\"); return 0;&#125; 4.SQL MODEANSI 使语法行为更符合sqlSTRICT_TRANS_TABLES 试用于事务，严格模式，报错不警告,不允许非法日期TRADITIONAL 严格模式，适用于事务非事务，不警告直接报错 5.sql分区RANGE分区：基于一个给定连续区间范围，把数据分配到不同分区LIST分区：类似RANGEHASH分区：基于给定的分区个数，把数据分配到不同分区KEY分区：类似于HASH分区RANGE\\LIST\\HASH分区键必须INT型 好处4点存储更多数据、优化查询、快速删除数据、获得更大查询吞吐量Range分区利用取值范围将数据分成分区12345678910CREATE TABLE emp(id INT NOT NULL,NAME VARCHAR(20),age INT)PARTITION BY RANGE(ID)(PARTITION p0 VALUES LESS THAN (6),PARTITION p1 VALUES LESS THAN (11),PARTITION pmax VALUES LESS THAN maxvalue); LIST分区是建立离散的之列表告诉数据库特定值在哪个分区123456789101112CREATE TABLE expense(expense_date DATE NOT NULL,category INT,amount DECIMAL (10,3))PARTITION BY LIST(category)(PARTITION p0 VALUES IN(3,5),#可字符串在5.5版本后PARTITION p1 VALUES IN(1,10),PARTITION p2 VALUES IN(4,9),PARTITION p3 VALUES IN(2),PARTITION p4 VALUES IN(6)); Columns分区可分为 RANGE Columns和LIST Columns分区都支持int\\date\\string,还支持多列123456789CREATE TABLE expense(a INT,b INT)PARTITION BY RANGE COLUMS(a,b)(PARTITION p0 VALUES IN(0,10),#可字符串在5.5版本后PARTITION p1 VALUES IN(10,10),PARTITION p2 VALUES IN(10,29)); HASH分区用来分散热点读，确保数据在预留分区平均分布，有常规分区和线性分区1234567891011121314#常规 平衡不方便CREATE TABLE emp(id INT NOT NULL,NAME VARCHAR(20),age INT)PARTITION BY HASH(ID) PARTITIONS 4;#线性 快速不平衡CREATE TABLE emp(id INT NOT NULL,NAME VARCHAR(20),age INT)PARTITION BY LINEAR HASH(ID) PARTITIONS 4; key分区类似HASH分区，数据类型除TEXThe BLOB以外都可以 RANGE&amp;LIST 分区管理 分区被删除了分区中的数据也被删除了123456789alter table xxx drop partition p2; #删alter table xxx add partition (partiton p5 values less than (2025)) #增 不能添加一个包含现有分区值列表中的任意值分区alter table xxx reorganize partition p3 into ( partition p2 values less than (2005), partition p3 values less than (2015)); #拆分alter table xxx reorganize partition p1,p2,p3 into ( partition p1 values less than (2015)); #合并 HASH&amp;KEY 分区管理12alter table xxx coalesce partition 2; #原4删2alter table xxx coalesce partition 8; #原4加8 6.SQL优化 通过慢查询日志定位效率低的sql,在查询过程中出现的情况可以用show processlist命令查看mysql进程，看锁表及进程状态 将慢的sql提取做explain分析，type的性能如下 ALL,全表扫瞄 index,索引全扫描 range,索引范围扫描 常见&lt;\\&lt;=>>=\\between ref,使用非唯一索引扫描或者唯一索引前缀扫描（联合索引） eq_ref,使用唯一索引 const/system,单表中最多有一个匹配行 NULL，不查表直接得到结果 自上而下效率越来越高 通过show profile分析sql123456select @@have_profiling; #查询是否支持select @@profiling; #查询是否开启set profiling=1; #开启show profiles; #显示sql的执行排列show profile for query 4; #查找具体某一条的状态show profile cpu for query 4; #查询莫一条在具体（all\\cpu\\block io\\context\\switch\\page faults）","path":"2018/10/31/Mysql笔记/"},{"title":"pomelo学习笔记","text":"环境12345678getBase() Application.getBase(); 获取应用程序的基本路径set(setting, val, attach); Application.set(); setting:应用程序的配置；val:需要设置的值；attach:是否将设配置应用到程序。设置或返回配置的值。get(setting) Application.get(); setting:应用程序的配置。获取配置的值enabled(setting) Application.enabled(); setting:应用程序的配置。检查配置是否启用disabled(setting) Application.disabled(); setting:应用程序的配置。检查配置是否禁用enbale(setting) Application.enbale(); setting:应用程序的配置。启用配置disable(setting) Application.disabled(); setting:应用程序的配置。禁用配置configure(env,fn,type) Application.configure();env:应用环境;fn:回调函数;type:服务类型. 初始化 1234567start() Application.start(); 启动应用程序。它会加载默认的组件和启动所有加载的组件。registerAdmin(moduleId,module,opts) Application.registerAdmin(); moduleId:(可选参数)模块id或者有modeule提供的模块Id;module:模块对象或者模块的工程函数;opts:模块构造函数的参数。filter(filter) Application.filter(); filter:provide before and after filter method。add a filter to before and after filterbefore(bf) Application.before(); bf:before filter。Add before filterafter(af) Application.after(); af:after filter。Add after filterload(name, component, opts) Application.load(); name:组件的名称（可选）；component：组件的实例或者组件的工厂函数；opts：组件构造函数的参数（可选）。加载组件loadConfig(key,val) Application.loadConfig(); key:环境配置的关键字;val:环境配置的值。导入json文件来配置环境。 组件相关 12345678910111213141516route(serverType, routeFunc) Application.route(); serverType:服务类型;routeFunc:路由功能函数,如：routeFunc(session, msg, app, cb)未指定的服务类型设置路由功能。如：app.route('area', routeFunc);var routeFunc = function(session, msg, app, cb) &#123; // all request to area would be route to the first area server var areas = app.getServersByType('area'); cb(null, areas[0].id);&#125; 获取相关配置，组件方法 123456789101112131415getMaster() Application.getMaster() 获得Maseter服务的信息getCurServer() Application.getCurServer() 获得当前服务的信息getServerId() Application.getServerId() 获得当前服务的IDgetServerType() Application.getServerType() 获得当前服务的类型getServers() Application.getServers() 获得所有当前服务的信息getServersFromConfig() Application.getServersFromConfig() 从server.json中获得所有服务的信息getServerTypes() Application.getServerTypes() 获得所有服务的类型getServerById(serverId) Application.getServerById() 根据服务ID从服务集群中获得服务的信息getServerFromConfig(serverId) Application.getServerFromConfig() 根据服务ID从server.json中获得服务的信息getServersByType(serverType) Application.getServersByType() 根据服务类型获取服务信息isFrontend(server) Application.isFrontend() 检查服务是否是一个前端服务isBackend(server) Application.isBackend() 检查服务是否是一个后端服务isMaster() Application.isMaster() 检查当前服务是否是主服务addServers(servers) Application.addServers() servers：新服务信息列表。添加新服务信息到正在运行的应用程序中removerServers(ids) Application.removerServers() ids：服务id列表。从当前运行的应用程序中删除服务信息。 创建和维护本地服务的信道。 12345createChannel(name) ChannelService.prototype.createChannel() 根据信道名称创建信道，如果该信道已存在则返回已存在的信道getChannel(name,create) ChannelService.prototype.getChannel() name:信道名称，create:如果为true，并且信道不存在时，则创建新的信道。根据信道名称获取信道destroyChannel(name) ChannelService.prototype.destroyChannel() 根据信道名称，删除信道pushMessageByUids(route, msg, uids, cb) ChannelService.prototype.pushMessageByUids() route：消息路由；msg：发送到客户端的消息；uids：接收消息的客户端列表，格式 [&#123;uid: userId, sid: frontendServerId&#125;]；cb：回调函数 cb(err)。根据uids将消息推送给客户端，如果uids中的sid未指定，则忽略相应的客户端broadcast(stype,route, msg, opts, cb) ChannelService.prototype.broadcast() stype：前端服务的类型;route：路由;msg：消息;opts：广播参数;cb：回调函数。广播消息到所有连接的客户端。 Channel 123456add(uid,sid) Channel.prototype.add() uid:用户编号；sid：用户连接到的前端服务id。添加指定用户到信道。leave(uid,sid) Channel.prototype.leave() uid:用户编号；sid：用户连接到的前端服务id。从信道中移除用户。getMembers() Channel.prototype.getMembers() 获得信道中的成员getMember(uid) Channel.prototype.getMember() 根据uid获取成员信息destroy() Channel.prototype.destroy() 销毁信道pushMessage(route,msg,cb) Channel.prototype.pushMessage() route：消息路由，msg：要推送的消息，cb：回调函数。将消息推送给信道的所有成员。 GlobalChannelService 1234567891011121314151617destroyChannel(name,cb) GlobalChannelService.prototype.destroyChannel() uid:用户编号；sid：用户连接到的前端服务id。添加指定用户到信道。add(name,uid,sid,cb) GlobalChannelService.prototype.add() name:信道名称；uid：用户id；sid：前端服务id；cb：回调函数。添加成员到信道。leave(name,uid,sid,cb) GlobalChannelService.prototype.leave() name:信道名称；uid：用户id；sid：前端服务id；cb：回调函数。从信道中移除成员。pushMessage() GlobalChannelService.prototype.pushMessage(serverType, route, msg,channelName, opts, cb)serverType：前端服务的类型, route：路由, msg：需要推送的消息,channelName：信道名称, opts：参数, cb：回调函数通过全局信道发送消息 LocalSessionService 1234567get(frontendId,sid,cb) LocalSeesionService.prototype.get() frontendId:会话链接的前端服务id,sid:会话Id,cb:回调函数。根据前端服务和会话id获得本地会话getByUid(name,uid,sid,cb) LocalSeesionService.prototype.getByUid() frontendId:会话链接的前端服务id,uid：绑定到会话的用户id，cb：回调函数。args: cb(err, localSessions)。根据前端服务和用户id获取本地会话。kickBySid(name,uid,sid,cb) LocalSeesionService.prototype.kickBySid() frontendId:会话链接的前端服务id,sid:会话Id,cb:回调函数。根据会话id踢掉该会话。kickByUid() LocalSeesionService.prototype.kickByUid() frontendId:会话链接的前端服务id,uid：用户id,cb:回调函数。根据用户id踢掉该会话。 LocalSession 123456789101112bind(uid,cb) LocalSeesion.prototype.bind() uid:用户编号;cb:回调函数。callfunction(err)。绑定当前会话，用于前端服务的推送和全局会话的绑定。unbind(uid,cb) LocalSeesion.prototype.unbind() uid:用户编号;cb:回调函数。callfunction(err)。取消绑定。set(key,value) LocalSeesion.prototype.set() 将key/value添加到本地会话中get(key) LocalSeesion.prototype.get() 根据key从本地会话中获取值。push(key,cb) LocalSeesion.prototype.push() 将本地会话中的key/value添加到全局会话中pushAll(cb) LocalSeesion.prototype.pushAll() 将本地会话中的所有key/value添加到全会话中 SessionService 1234567kick(uid,cb) SeesionService.prototype.kick() 踢掉该用户的所有离线会话kickBySession(sid,cb) SeesionService.prototype.kickBySession() sid:会话编号;cb:回调函数。根据会话id踢掉一个在线用户sendMessage(sid,msg) SeesionService.prototype.sendMessage()根据会话id向客户端发送消息sendMessageByUid(uid,msg) SeesionService.prototype.sendMessageByUid() 根据用户id向客户端发送消息 Pomelo ` bashcreateApp(opts) Pomelo.create() 创建一个Pomelo 应用程序","path":"2018/10/23/pomelo学习笔记/"},{"title":"node笔记","text":"第一章 node简介1.1 node的特点 1.1.1 异步I/O 绝大多数操作以异步方式进行调用 1.1.2 事件与回调函数 1.1.3 单线程，但是可以用WebWorkers的方式解决单线程的问题（子进程），用Master-Worker用master统一管理子进程 1.1.4 跨平台 1.1.5 c++速度大约是node的2.5倍 1.2 模块机制 1.2.1 分为核心模块和文件模块，require没带路径的为核心模块，直接加载进内存，带路径的为文件模块,核心模块中有c++和javascript两部分，其中buffer、crypto、evals、fs、os、等都是c++部分的 1.2.2 npm安装的核心模块插件在package.json中定义 1.3 异步I/O 1.3.1 操作系统内核对I/O只有：阻塞I/O和非阻塞I/O，node中的异步I/O模型由事件循环、观察者、请求对象、I/O线程池 整个系统可以理解为事件循环相当于厨子，不停的询问是否有新的订单，观察者相当于收银员，收到用户的订单将订单分给厨子，而订单相当于请求对象，参数、方法、回调函数斗封装在请求对象中, 以上是异步I/O的第一步，io线程池相当于放订单的桌子， 请求对象-&gt;I/O线程池-&gt;观察者-&gt;事件循环 1.3.2 非异步的I/O主要是setTimeout(),setInterval(),setImmediate(),process.nextTick() 1.4 异步编程 1.4.1 异步编程的解决方案分为3个： 1）事件发布/订阅模式 2）Promise/Deferred模式 3）流程控制库 1.4.2 事件发布/订阅模式 123456//订阅emitter.on(\"event1\",function(message)&#123; console.log(message);&#125;);//发布emitter.on('event1',\"I Love you\"); 1）继承events模块 123456var events = require('events');function Stream()&#123; events.EventEmitter.call(this);&#125;util.inherits(Stream,events.EventEmitter); 2)利用事件队列解决崩溃问题 事件发布/订阅模式中一般只有一个once()方法，用一个『状态锁』或者『事件队列』防止崩溃 状态锁 12345678910var status = \"ready\";var select = function(callback)&#123; if(status == \"ready\" )&#123; status = \"pending\"; db.select(\"SQL\", function(results)&#123; status = \"ready\"; callback(results); &#125;); &#125;&#125;; 事件队列 1234567891011var proxy = new events.EventEmitter();var status = function (callback) proxy.once(\"selected\", callback); if(status === \"ready\")&#123; status = \"pending\"; db.select(\"SQL\", function(result)&#123; proxy.emit(\"selected\",result); status = \"ready\"; &#125;); &#125;&#125; 3）多异步之间的协作方案 借组一个第三方函数和第三方变量来处理异步协作的结果 123456789101112var after = function (times,callback)&#123; var count = 0, results = &#123;&#125;; return function (key, value)&#123; result[key] = value; count++; if(count === times)&#123; callback(results); &#125; &#125;&#125;var done = after(times, render); 1.4.3 Promise/Deferred模式 Promise是高级接口，事件是低级接口，Promise更像链表 1.4.4 async流程控制模块 1）async的series()方法实现串行（不传参） 12345678910async.series([ function (callback)&#123; fs.readFile('file1.txt','utf-8',calback); &#125;, function (callback)&#123; fs.readFile('file2.txt','utf-8',calback); &#125;],function (err,result)&#123; //result = [file1.txt,file2.txt]等价于先处理file1.txt，在处理file2.txt，错误回调&#125;); 2）async的parallel()方法实现并行 12345678910async.parallel([ function (callback)&#123; fs.readFile('file1.txt','utf-8',calback); &#125;, function (callback)&#123; fs.readFile('file2.txt','utf-8',calback); &#125;],function (err,result)&#123; //result = [file1.txt,file2.txt]等价于并行处理file1.txt，在处理file2.txt，错误回调&#125;); 3）async的waterfall()方法实现串行（传参） 略 4）async.auto()可以根据依赖关系自动分析，以最佳顺序执行 略 1.4.5 流程控制模块Step 1)Step接受任意数量任务，所有任务传行执行 1234567891011Step( function (callback)&#123; fs.readFile('file1.txt','utf-8',this); &#125;, function (callback)&#123; fs.readFile('file2.txt','utf-8',this); &#125;, function done(err, content) &#123; console.log(content); &#125;); 2)Step实现异步任务并行执行要用this的parallel() 1234567891011Step( function (callback)&#123; fs.readFile('file1.txt','utf-8',this.parallel()); &#125;, function (callback)&#123; fs.readFile('file2.txt','utf-8',this.parallel()); &#125;, function done(err, content) &#123; console.log(arguments); &#125;); 1.4.6流程控制模块wind 1)wind的$await()方法实现异步等待 2）wind的whenAll()处理并发 1.5 异步并发控制 1.5.1 bagpipe解决办法（API添加过载保护，用队列控制并发） 1234567891011var Bagpipe = require('bagpipe');//设定最大并发数为10var bagpipe = new Bagpipe(10);for(var i = 0; i&lt; 100;i++)&#123; bagpipe.push(async, function ()&#123; &#125;);&#125;bagpipe.on('full',function (length)&#123; console.warn('底层系统处理不及时');&#125;); 1.5.2 拒绝模式 123var bagpipe = new Bagpipe(10,&#123; refuse: true&#125;); 1.5.3 超时控制 123var bagpipe = new Bagpipe(10, &#123; timeout: 3000&#125;); 1.6 内存管理 1.6.1 v8内存分为新生代和老生代的 node –max-old-space-size 2048 xxx.js 调整内存大小执行某个脚本 v8堆内存64位系统是1.4G,32位系统是0.7G 新生代内存的回收机制是将堆内存一分为2，使用中的是From，空的是to，进行垃圾回收时，是将from中的存活对象复制到to中，然后释放非存活的，同时from和to对换，缺点是只能使用一半的内存空间 老生带内存的回收机制是将from中的使用的标记，回收未使用的 1.6.2 外部访问内部的变量的方法叫闭包 还有的说是内部变量无法被外部访问的过程叫闭包 1.6.3 查看内存使用process.memoryUsage() os.totalmem os.freemem 1.7 Buffer 1.7.1 Buffer与字符串转换 123new Buffer(str, [encoding]);buf.write(string, [offset], [length], [encodeing]);buf.tostring([encoding], [start], [end]); 1.8 网络 1.8.1 tcp协议中的osi模型（分为 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层） server 12345678910111213var net = require('net');var server = net.createServer(function(socket)&#123; server.on('data',function(data)&#123; &#125;); server.on('end',function(data)&#123; &#125;); server.on('error',function(data)&#123; &#125;); server.write('data');&#125;);server.listen(port,function()&#123;&#125;) client 12345678910var net = require('net');var client = net.connect(&#123;port: 8124&#125;,function(socket)&#123; client.on('data',function(data)&#123; &#125;); client.on('end',function(data)&#123; &#125;); client.on('error',function(data)&#123; &#125;); client.write('data');&#125;); 1.8.2 UDP是用户数据包协议，一个套接字可以与多个UDP通信 server 12345678910var dgrm = require(\"dgrm\");var server = dgrm.createSocket(\"udp4\");server.on(\"message\", function (msg, rinfo)&#123; console.log(\"xxx\");&#125;);server.on(\"listening\", function() &#123; var address = server.address(); console.log(\"xxx\");&#125;);server.bind(41234); client 123456var dgram = require('dgram');var messgae = new Buffer(\"xxxx\");var client = dgram.createSocket(\"udp4\");clinet.send(message, 0, message.length, 41234, \"localhost\", function(err,bytes)&#123; client.close();&#125;); 1.8.3 HTTP是构建在TCP之上属于应用层协议 123456789101112131415161718192021222324252627282930313233343536373839404142https_request : function(host, path, post_data, cb)&#123; var reqdata = JSON.stringify(post_data); var options = &#123; hostname: host, port: 443, method: 'POST', path: path, headers: &#123; 'Content-Type': 'application/json' &#125; &#125;; var req_time_out = setTimeout(function() &#123; req.abort(); cb(400, &#123;code:400,message:'请求超时'&#125;); logger.n.info('Got Request Timeout.'); &#125;, 10000); var req = https.request(options, function (res) &#123; clearTimeout(req_time_out); //等待响应60秒超时 var res_time_out = setTimeout(function() &#123; res.destroy(); cb(400, &#123;code:400,message:'响应超时'&#125;); logger.n.info('Got Response Timeout.'); &#125;, 60000); var status_code = res.statusCode; var body = null; logger.n.info(\"Got status_code: \" + status_code); res.on('data',function(data)&#123; body = JSON.parse(data); &#125;).on('end', function()&#123; clearTimeout(res_time_out); cb(status_code, body); &#125;); &#125;).on('error', function(e) &#123; cb(400, &#123;code:400,message:e.message&#125;); logger.n.info(\"Got error: \" + e.message); &#125;); req.write(reqdata); req.end(); &#125; 1.8.4 WebSocket client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 var client= new net.Socket();var flag = true;var port = 0;client.on('connect',function ()&#123; //正常连接 flag = true; logger.boot.info('socket Connection succeed');&#125;);client.on('end', function() &#123; //flag=false; logger.n.warn('!!!!!tcp_client disconnected'); setTimeout(Fight_Service.tcp_reconnect, 1000);&#125;);client.on('data',function(data)&#123; //得到服务端返回来的数据 Fight_Service.processResp(data);&#125;);client.on('error',function(error)&#123; //错误出现之后关闭连接 flag = false; logger.n.error('socket error:' + error); client.destroy(); setTimeout(Fight_Service.tcp_reconnect, 1000);&#125;);client.on('close',function()&#123; //正常关闭连接 flag = false; logger.n.warn('socket Connection closed'); client.destroy();&#125;);Fight_Service.tcp_reconnect = function(worker_id)&#123; //创建socket客户端 client.setEncoding('binary'); if (port == 0 )&#123; //连接到服务端115.159.186.60 8400 // logger.boot.info(\"socket process_work_id:\" + worker_id); worker_id = worker_id % 8; port = 8400 + worker_id; &#125;else&#123; logger.boot.info(\"socket tcp_reconnect\"); &#125; logger.boot.info(\"socket_port_id:\" + port); client.connect(port,\"10.96.71.91\");&#125; 1.9 多进程 1.9.1 child_process模块 1）spawn()启动一个子进程执行命令，无回调，无超时 2）exec()启动一个子进程执行命令，有回调，有超时 3）execFile()启动一个子进程执行可执行文件 4）fork()启动node子进程执行js文件模块 12345var fork = require('child_process').fork;var cpus = require('os').cpus();for(var i = 0; i &lt; cpus.length; i++)&#123; fork('./worker.js');&#125; 1.9.2 进程间通信IPC，主线程与工作线程之间通过onmessage()和postMessage()进行通信，子进程对象则由send()方法实现主进程向子进程发送数据 1.9.3 句柄是一种用来标识资源的引用，用来拓展有限的文件描述符 1234567child.send(message,[sandHandle])如（child.send('server',server)）;子进程代码process.on('message',function(m, server)&#123; if(m == 'server')&#123; xxxxx&#125;&#125;) 1.9.4 父进程可以通过kill()方法给子进程发送一个SIGTERM信号杀进程 1234567891011121314151617181920212223242526chid.kill([signal]);process.kill(pid, [signal]);``` 在退出中加入自动重启可能会有新用户进来请求丢失的情况，工作进程在得知退出时，向主进程发送一个自杀信号（达到先创建在退出进程）``` bash/** * cluster mode */if ( opts.get('cluster') || config.APP_CLUSTER.ENABLE) &#123; var cluster = require('cluster'); if (cluster.isMaster) &#123; console.log('[CLUSTER MODE] MASTER'); for (var i=0; i&lt;config.APP_CLUSTER.NUM; i++) &#123; cluster.fork(); &#125; cluster.on('exit', function(worker, code, signal) &#123; console.log('worker ' + worker.process.pid + ' died'); cluster.fork(); &#125;); return; &#125; console.log('[CLUSTER MODE] WORKER');&#125; 1.10 插件 1.10.1 Sequelizejs 此插件在option索引的位置千万不能写错，写错有大几率导致db堵塞 123456789101112131415161718192021Model.findAll(&#123; attributes: ['foo', ['bar', 'baz']]&#125;);SELECT foo, bar AS baz ...Model.findAll(&#123; attributes: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']]&#125;);SELECT COUNT(hats) AS no_hats ...Post.findAll(&#123; where: &#123; [Op.or]: [&#123;authorId: 12&#125;, &#123;authorId: 13&#125;] &#125;&#125;);SELECT * FROM post WHERE authorId = 12 OR authorId = 13;Order.findAll(&#123;attributes:['name', [sequelize.fn('SUM', sequelize.col('price')), 'sum']], group:'name', having:['COUNT(?)&gt;?', 'name', 1], raw:true&#125;).then(function(result)&#123; console.log(result);&#125;)SELECT `name`, sum(`price`) AS `sum` FROM `orders` AS `Orders` GROUP BY name HAVING COUNT('name')&gt;1; 1.10.2 Lodashjs [文档](https://www.lodashjs.com/docs/4.17.5.html) _.indexOf(array, value, [fromIndex=0]) number): Returns the index of the matched value, else -1. 123456_.indexOf([1, 2, 1, 2], 2);// =&gt; 1 // Search from the `fromIndex`._.indexOf([1, 2, 1, 2], 2, 2);// =&gt; 3 _.dropRight(array, [n=1]) (Array): Returns the slice of array. 12345678_.dropRight([1, 2, 3]);// =&gt; [1, 2] _.dropRight([1, 2, 3], 2);// =&gt; [1]_.dropRight([1, 2, 3], 0);// =&gt; [1, 2, 3] _.filter(collection, [predicate=_.identity]) (Array): Returns the new filtered array. 1234567var users = [ &#123; 'user': 'barney', 'age': 36, 'active': true &#125;, &#123; 'user': 'fred', 'age': 40, 'active': false &#125;]; _.filter(users, function(o) &#123; return !o.active; &#125;);// =&gt; objects for ['fred'] _.find(collection, [predicate=_.identity], [fromIndex=0]) (*): Returns the matched element, else undefined. 12345678 var users = [ &#123; 'user': 'barney', 'age': 36, 'active': true &#125;, &#123; 'user': 'fred', 'age': 40, 'active': false &#125;, &#123; 'user': 'pebbles', 'age': 1, 'active': true &#125;]; _.find(users, function(o) &#123; return o.age &lt; 40; &#125;);// =&gt; object for 'barney' _.forEach(collection, [iteratee=_.identity]) 12345678_.forEach([1, 2], function(value) &#123; console.log(value);&#125;);// =&gt; Logs `1` then `2`. _.forEach(&#123; 'a': 1, 'b': 2 &#125;, function(value, key) &#123; console.log(key);&#125;); _.groupBy(collection, [iteratee=_.identity]) (Object): Returns the composed aggregate object. 123456_.groupBy([6.1, 4.2, 6.3], Math.floor);// =&gt; &#123; '4': [4.2], '6': [6.1, 6.3] &#125; // The `_.property` iteratee shorthand._.groupBy(['one', 'two', 'three'], 'length');// =&gt; &#123; '3': ['one', 'two'], '5': ['three'] &#125; #Promise.map Promise.all 相当于事务 _.map(collection, [iteratee=_.identity]) (Array): Returns the new mapped array. 123456789function square(n) &#123; return n * n;&#125;_.map([4, 8], square);// =&gt; [16, 64] _.map(&#123; 'a': 4, 'b': 8 &#125;, square);// =&gt; [16, 64] (iteration order is not guaranteed) #Promise.reduce是顺序执行 _.reduce(collection, [iteratee=_.identity], [accumulator]) - (*): Returns the accumulated value. 1234f_.reduce([1, 2], function(sum, n) &#123; return sum + n;&#125;, 0);// =&gt; 3 _.isEmpty(value) (boolean): Returns true if value is empty, else false. 1234567891011121314_.isEmpty(null);// =&gt; true _.isEmpty(true);// =&gt; true _.isEmpty(1);// =&gt; true _.isEmpty([1, 2, 3]);// =&gt; false _.isEmpty(&#123; 'a': 1 &#125;);// =&gt; false 项目案例 略 1.10.3 Moment.js [文档](http://momentjs.cn) 案例使用 12moment(event.start_time).startOf('day')/1000;moment.unix(moment().startOf('month')/1000).utcOffset(config.TIME_ZONE_DIFF).format(\"YYYY-MM-DD HH:mm:ss\");","path":"2018/08/21/node笔记/"},{"title":"翻译提取替换","text":"提取提取客户端资源文件之前先要用uc-utf8.php转utf-8 把unicode码转成utf-8的日文在提取将要提取文字的文件整合与getFromHtml.sh 放在同目录下12345678#!/bin/bash#sh getFromHtml.sh under the template fold#Change filelist.csv to excel file, and give it to translatorLANG=C grep -r -n -v '^[[:cntrl:][:print:]]*$' . | grep -v \"using UnityEngine;\" | grep -v svn | grep -v // | grep -v \\* | grep -v \"\\&#123;\\*\" | grep -v \"\\\"Name\\\"\" &gt; ~/lj_2_3_server.csvsed -i 's@\\t@ @g' ~/lj_2_3_server.csvsed -i 's@\\([^:]*\\):\\([0-9]*\\):@\\1\\t\\2\\t@' ~/lj_2_3_server.csv 点击下载 可以脚本文件内修改输出路径及文件名运行命令提取内容sh getFromHtml 取出后的excel先在编辑软件里打开编码改成ansi, 否则直接excel打开会乱码在excel内，全选，点击数据-&gt;分列-&gt;分隔符号-&gt;Tab键-&gt;确定。。。。以Tab键分割内容完成后的数据格式如下：(A列为行数，B列为行号，C列为提取的原字符)如果有发现提取到不需要翻译的错误的，可直接整行删除。。。提交翻译 替换翻译后的文件如果为xls，在最后另起一列，用公式=A1&amp;”^”&amp;B1&amp;”^”&amp;C1连接，拖到底，用连接的主要目的是让文件、行、数据之间有个特殊的符号分割^ 这个符号基本见不到所以用这个，将最后列的数据拷贝到sublime，替换”^ “ 为 “^”去掉多余的数据与行之间的一个空格，然后将\\替换为@@@或者奇怪不重复的符号，如果不替换转换会被转换掉，最后将sublime上的代码考到新建的一个txt中另存为utf-8，上传到服务器对应的目录下面，修改changeHtml.sh这个文件中判断中间的分割符号保存，整个文件权限777. 1234567891011121314151617181920212223242526272829303132#!/bin/bash#sh changeHtml.sh result_file#result_file' content#file's path line_no old_content new_contentfile=$1if [ -z $file ]then echo \"Input result_file\" exitfiwhile read linedo IFS=\"^\" arr=($line) filename=$&#123;arr[0]&#125; line_num=$&#123;arr[1]&#125; str_kr=$&#123;arr[2]&#125; if [ $str_kr ] then echo $filename echo $line_num echo $str_kr sed -i ''$line_num' c\\'$str_kr'' $filename else echo $line fidone &lt; $file 运行命令替换内容sh changeHtml.sh text.txt 运行完.asset的文件是没办法替换的，要手动自行替换 text.txt数据格式如下点击下载","path":"2018/08/03/翻译提取替换/"},{"title":"redis笔记","text":"Redis是什么、特点、优势redis是Key-Value数据库,数据包含各种数据 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet等redis支持数据持久化，重启再次加载,支持数据备份(支持分布式),Redis是单进程单线程的Redis的优势性能高 读速度110000/s 写速度81000/s丰富的数据类型 redis安装（Linux）、启动、退出、设置密码、远程连接2.1 安装redis下载redis安装包（如：redis-2.8.17.tar.gz） 1234tar -zxvf redis-2.8.17.tar.gzcd redis-2.8.17makesudo make install 2.2 后台启动服务端1nohup redis-server &amp; 2.3 启动客户端、验证1234cd /usr/local/binredis-cliset var \"hello world\"get var Reis key序号 Redis keys命令及描述1 DEL key该命令用于在 key 存在是删除 key。2 DUMP key序列化给定 key ，并返回被序列化的值。3 EXISTS key检查给定 key 是否存在。4 EXPIRE key seconds为给定 key 设置过期时间。5 EXPIREAT key timestampEXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。6 PEXPIRE key milliseconds设置 key 的过期时间亿以毫秒计。7 PEXPIREAT key milliseconds-timestamp设置 key 过期时间的时间戳(unix timestamp) 以毫秒计8 KEYS pattern查找所有符合给定模式( pattern)的 key 。例如keys * 返回所有的key9 MOVE key db将当前数据库的 key 移动到给定的数据库 db 当中。10 PERSIST key移除 key 的过期时间，key 将持久保持。11 PTTL key以毫秒为单位返回 key 的剩余的过期时间。12 TTL key以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。13 RANDOMKEY从当前数据库中随机返回一个 key 。14 RENAME key newkey修改 key 的名称15 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。16 TYPE key返回 key 所储存的值的类型。…中文文档 Redis 发布订阅占时没用过，看起来跟微信公众号一样,Pub/Sub做延时队列可以用在玩家登录排队上 Redis事务一个事务从开始到结束经过以下三个阶段： 开始事务命令入队执行事务例子 1234567891011localhost:6379&gt; MULTIOKlocalhost:6379&gt; set name jihiteQUEUEDlocalhost:6379&gt; get nameQUEUEDlocalhost:6379&gt; sadd language \"c++\" \"python\" \"java\"QUEUEDlocalhost:6379&gt; smembers languageQUEUEDlocalhost:6379&gt; exec 说明：事务以MULTI开始，以EXEC结束 关闭持久化与持久化(RDB)bgsave做镜像全量持久化，aof做增量持久化RDB相当于快照，是fork一个子进程，快照成功后替换aof相当于日志，cow，copy and write,一条一条的数据 这是redis与其他缓存服务的比较明显的特点,如memcache修改配置文件，改完后重启。123#save 900 1 #save 300 10 #save 60 10000 或执行操作命令1CONFIG SET save \"\" redis相比memcached有哪些优势？ (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型(2) redis的速度比memcached快很多(3) redis可以持久化其数据 redis常见性能问题和解决方案： (1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内(4) 尽量避免在压力很大的主库上增加从库(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。 Redis 常见的性能问题都有哪些？如何解决？1).Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。2).Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。3).Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。4). Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内 Redis分布式锁拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 Redis做异步队列一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。","path":"2018/08/01/redis笔记/"},{"title":"项目各种配置文件","text":"srpg.conf12345678910111213141516171819202122232425262728server &#123; listen 80; listen 443 ssl;# server_name alctwobt.ssl.91dena.cn; server_name alccn2-release.ssl.91dena.cn;# ssl on; ssl_certificate /root/cert/91dena_cn.pem; ssl_certificate_key /root/cert/91dena_cn.key; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; ## APP 11 location / &#123; # proxy proxy_pass http://127.0.0.1:5000/; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # connect to backend with keepalives proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_send_timeout 30s; proxy_read_timeout 60s; proxy_connect_timeout 30s; &#125; access_log /home/log/nginxlog/cnrelease/alccn2.ssl.91dena.cn.access.log main; error_log /home/log/nginxlog/cnrelease/alccn2.ssl.91dena.cn.error.log;&#125; 点击下载 nginx123456789101112131415161718192021222324252627282930user nginx;worker_processes auto;worker_rlimit_nofile 150000;error_log /tmp/error.log;events &#123; worker_connections 65535; multi_accept on ;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" $request_time' ' $status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\" $upstream_response_time'; access_log /tmp/access.log; sendfile on; tcp_nopush on; keepalive_timeout 120; gzip on; include /etcinx/title/*.conf;&#125; 点击下载 srpg-app123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#!/bin/bash### BEGIN INIT INFO# Provides: webapp# Required-Start: $syslog $remote_fs# Required-Stop: $syslog $remote_fs# Should-Start: $local_fs# Should-Stop: $local_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Alchemist Webapp# Description: Alchemist Webapp### END INIT INFO#### BEGIN CHKCONFIG INFO# chkconfig: 2345 55 25# description: Alchemist Webapp### END CHKCONFIG INFOUSER=\"webapp\"NAME=\"webapp\"NODE_ENV=\"production\"NODE_BIN_DIR=\"/usr/localde/bin\"NODE_PATH=\"/usr/localdebde_modules\"APPLICATION_PATH=\"ar/webapps/alchemist/currentde/app/app.js\"APPLICATION_WORKDIR=\"ar/webapps/alchemist/currentde/app/\"APPLICATION_OPTION=\"\"LOGFILE=\"ar/webapps/alchemist/log/forever/app.log\"MIN_UPTIME=\"5000\"SPIN_SLEEP_TIME=\"10000\"PATH=$NODE_BIN_DIR:$PATHexport NODE_PATH=$NODE_PATHstart() &#123; echo `runuser -l \"$USER\" -c \"forever list\"` | grep -q \"$APPLICATION_PATH\" if [ \"$?\" -eq \"0\" ]; then echo \"$NAME is already running.\" RETVAL=0 else echo \"Starting $NAME\" runuser -l \"$USER\" -c \"\\ export NODE_ENV=$NODE_ENV &amp;&amp; forever \\ -a \\ -l $LOGFILE \\ --minUptime $MIN_UPTIME \\ --spinSleepTime $SPIN_SLEEP_TIME \\ --workingDir $APPLICATION_WORKDIR \\ start $APPLICATION_PATH $APPLICATION_OPTION\" 2&gt;&amp;1 &gt; /dev/null &amp; RETVAL=$? fi&#125;stop() &#123; echo `runuser -l \"$USER\" -c \"forever list\"` | grep -q \"$APPLICATION_PATH\" if [ \"$?\" -eq \"0\" ]; then echo \"Shutting down $NAME\" # Tell Forever to stop the process. runuser -l \"$USER\" -c \"forever stop $APPLICATION_PATH\" 2&gt;&amp;1 &gt; /dev/null RETVAL=$? else echo \"$NAME is not running.\" RETVAL=0 fi&#125;restart() &#123; stop start&#125;status() &#123; echo `runuser -l \"$USER\" -c \"forever list\"` | grep -q \"$APPLICATION_PATH\" if [ \"$?\" -eq \"0\" ]; then echo \"$NAME is running.\" RETVAL=0 else echo \"$NAME is not running.\" RETVAL=3 fi&#125;case \"$1\" in start) start ;; stop) stop ;; status) status ;; restart) restart ;; *) echo \"Usage: &#123;start|stop|status|restart&#125;\" exit 1 ;;esacexit $RETVAL 点击下载 td-agent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138###### Output descriptions:### Treasure Data (http://www.treasure-data.com/) provides cloud based data# analytics platform, which easily stores and processes data from td-agent.# FREE plan is also provided.# @see http://docs.fluentd.org/articles/http-to-td## This section matches events whose tag is td.DATABASE.TABLE&lt;match td.*.*&gt; @type tdlog apikey YOUR_API_KEY auto_create_table buffer_type file buffer_path /var/log/td-agent/buffer/td &lt;secondary&gt; @type file path /var/log/td-agent/failed_records &lt;/secondary&gt;&lt;/match&gt;## match tag=debug.** and dump to console&lt;match debug.**&gt; @type stdout&lt;/match&gt;###### Source descriptions:#### built-in TCP input## @see http://docs.fluentd.org/articles/in_forward&lt;source&gt; @type forward&lt;/source&gt;## built-in UNIX socket input#&lt;source&gt;# @type unix#&lt;/source&gt;# HTTP input# POST http://localhost:8888/&lt;tag&gt;?json=&lt;json&gt;# POST http://localhost:8888/td.myapp.login?json=&#123;\"user\"%3A\"me\"&#125;# @see http://docs.fluentd.org/articles/in_http&lt;source&gt; @type http port 8888&lt;/source&gt;## live debugging agent&lt;source&gt; @type debug_agent bind 127.0.0.1 port 24230&lt;/source&gt;###### Examples:#### File input## read apache logs continuously and tags td.apache.access#&lt;source&gt;# @type tail# format apache# path /var/log/httpd-access.log# tag td.apache.access#&lt;/source&gt;## File output## match tag=local.** and write to file#&lt;match local.**&gt;# @type file# path /var/log/td-agent/access#&lt;/match&gt;## Forwarding## match tag=system.** and forward to another td-agent server#&lt;match system.**&gt;# @type forward# host 192.168.0.11# # secondary host is optional# &lt;secondary&gt;# host 192.168.0.12# &lt;/secondary&gt;#&lt;/match&gt;## Multiple output## match tag=td.*.* and output to Treasure Data AND file#&lt;match td.*.*&gt;# @type copy# &lt;store&gt;# @type tdlog# apikey API_KEY# auto_create_table# buffer_type file# buffer_path /var/log/td-agent/buffer/td# &lt;/store&gt;# &lt;store&gt;# @type file# path /var/log/td-agent/td-%Y-%m-%d/%H.log# &lt;/store&gt;#&lt;/match&gt;#&lt;match *.**&gt;# type file# path /var/log/td-agent/error.log#&lt;/match&gt;&lt;match alchemist.**&gt; type forward heartbeat_type tcp buffer_type file buffer_path /var/tmp/td-agent/forward.*.buffer buffer_chunk_limit 8m # チャンクサイズ buffer_queue_limit 256 # 1queueに保存できるchunk数の上限 flush_interval 1s # 10秒に1回送信 flush_at_shutdown true # シャットダウン時にチャンクを処理するか?(ファイルバッファのみ有効) retry_wait 5s # 再送実施までの待ち時間 retry_limit 2 # 再送実施回数 require_ack_response true expire_dns_cache 0 dns_round_robin true &lt;server&gt; host mongodb.alccn.91dena.cn port 24224 &lt;/server&gt; # ログ送信失敗時のファイル # # &lt;secondary&gt; # # type file # # path /var/log/td-agent/failed/forward-failed # #&lt;/secondary&gt; &lt;/match&gt; 点击下载","path":"2018/07/31/项目各种配置文件/"},{"title":"ALC_Sentry","text":"1) 安装环境执行命令创建名为sentry的数据库createdb -E utf-8 sentry为sentry项目初始化数据sentry –config=~/.sentry/sentry.conf.py upgrade创建新用户sentry –config=~/.sentry/sentry.conf.py createuser然后就可以启动服务了sentry –config=~/.sentry/sentry.conf.py start另外，还需要启动Workersentry –config=~/.sentry/sentry.conf.py celery worker -B假设web服务器端口是9000，那么访问localhost:9000就能开始使用sentry了！ source /usr/local/vir-sentry/bin/activatesentry –config=~/.sentry/sentry.conf.py start &gt;&gt; /usr/local/vir-sentry/logs/sentry.log 2&gt;&amp;1 &amp; 2）相关命令2.1启动su - webappsource /usr/local/vir-sentry/bin/activatesupervisord -c /etc/supervisord.confsupervisorctl start all2.2关闭命令su - webappsource /usr/local/vir-sentry/bin/activatesupervisorctl stop allkillall supervisord *创建账号 sentry createuser3)基于node的测试demoraven-node-master.zip 4.）界面显示 web 服务器相关配置","path":"2018/07/24/ALC-Sentry/"},{"title":"alchemist_manage服务器部署","text":"manage服务器代码上传copy srpg_too 目录到 /var/webapps/alchemist_mnt (文件所有者必须为webapp) ruby运行环境构建2.1 检查依赖-ruby(v2.2.2p95~)-gem bundle-Node.js-npm-bower-msyql-redis2.1 设置gem源为淘宝源Gemfile （描述gem之间依赖文件）需要如下修改source ‘https://gems.ruby-china.org/&#39;2.2 安装gem filesu - webappbundle install2.2.1 安装bundle 命令不存在，。gem install bundle2.2.2 提示gem命令不存在，就执行rbenv global 2.2.2， 如果无法运行就重新安装ruby 2.2.2 版本，流程如下su - webappgit clone https://github.com/rbenv/rbenv.git ~/.rbenvcd ~/.rbenv &amp;&amp; src/configure &amp;&amp; make -C srcecho ‘export PATH=”$HOME/.rbenv/bin:$PATH”‘ &gt;&gt; ~/.bash_profile~/.rbenv/bin/rbenv initecho ‘eval “$(rbenv init -)”‘ &gt;&gt; ~/.bash_profilesource ~/.bash_profilegit clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-buildrbenv install 2.2.2rbenv global 2.2.2ruby -v Cap环境部署3.1 配置SSH无密码登录配置config/deploy/produciton.rb ssh无密码登陆（id_rsa.pub和authorized_keys） 设置authorized_keys，记得chmod 600，否则无法生效）3.1.1 生成sshkey:cd ~/.sshssh-keygen输入公钥名：id_rsa3.1.2 配置authorized_keyscat id_rsa.pub &gt;&gt; authorized_keyschmod -R 600 authorized_keyschmod 700 ~/.ssh备注：如果还是无法实现无密码登录，再清空下~/.ssh/koown_hosts文件（echo “” &gt; ~/.sshown_hosts);3.1.3执行以下deploy命令：production环境为例cd currentbundle exec cap production mkdir:socketsbundle exec cap production bower:install4.前端bower模块安装4.1 Node.js 安装bowernpm install -g bower –registry=https://registry.npm.taobao.org (-g不一定要)4.2install Bowerfile bundle exec rake bower:install4.3 manage server DB构建bundle exec rake maint:create maint:migrate 4.4 添加管理账号 bundle exec rake maint:seed 4.5 配置crontab 缺少crontab 会影响预约奖励发放 cd 根目录（current/） gem install whenever ，检查config/schedule.rb是否存在 whenever -w（写入到crontab 中） 查看log/cron_log.log日志是否已生成。","path":"2018/07/11/alchemist-manage服务器部署/"},{"title":"hexo 常用笔记","text":"建站的过程网上一大把就不记录了，主要写下遇到的几个问题 github上的项目名称一定要和自己在github上的用户名一致，否则会生成静态文件后点开会白屏 多看看官方手册上面有详细记录https://hexo.io/zh-cn/docs hexo g -dhexo cleanhexo shexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件,再运行hexo n “xxxx”来生成md博文","path":"2018/07/03/hexo-安装遇到的问题/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/06/15/hello-world/"}]}